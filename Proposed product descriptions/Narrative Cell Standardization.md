### Summary

The goal of this proposed work is to change how we use Jupyter Notebook cells for rendering KBase methods and data. Currently we use modified Markdown cells for that purpose, with method and app cells making direct kernel calls to invoke their functions. Although this is functional, it carries many security issues, and does not conform to the Jupyter standard for extensions.

This work would change those to behave as code cells, conforming to the Jupyter
notebook methodology and Jupyter extension specifications.

### Background

When we started the Narrative project back in 2013, the IPython notebook was at an early dev version. At that time, there were mocked up designs for point-and-click-based cells (that have now grown into KBase method and app cells). Though the eventual goal was to serve both computationalists and experimentalists, our first focus was on support for experimentalists with the simpler interface. This was stymied, at the time, by limited support in the IPython notebook for visual, interactive (i.e. JavaScript-based) extensions. However, Markdown cells had the ability to render arbitrary JavaScript. We leveraged that to build the suite of App and Method cells, as well as a framework for rendering a library of interactive widgets on the front end. These were limited, however, to only working in the user's browser, which can require doing some heavy computation.

As we developed things for KBase needs, the IPython (later, Jupyter) team developed similar things to support their broader userbase. This includes a set of code-cell based "widgets" that interact directly with the kernel, and can trigger computation that takes place on the back-end, allowing the front-end to only render the visual output.

This brings us to today. The KBase cells are still modified markdown cells that render semi-raw JavaScript. Jupyter notebook code cells, however, support more tightly designed extensions that allow close interaction between the kernel's computational power and the browser for rendering. It would be very beneficial to the KBase project to migrate our cell representation to code cells.

### Description

The focus of this project is on the standardization of KBase cells to extend code cells in all cases. Currently, our changes to markdown cells for rendering methods and apps are problematic in the following ways:

  1. KBase changes to markdown cells are not sustainable with current and upcoming changes to Jupyter.
  2. By their nature, our changes to markdown cells are not secure. We had to modify Jupyter to allow running arbitrary JavaScript in markdown cells.
  3. Interactions are all currently from the client (i.e. browser) to various services. This has several implications:
    a. Puts undue stress on the client's browser to download, process, and render data components that can be done more efficiently by the kernel.
    b. This changes the central metaphor of the Jupyter notebook, where code should be written in cells and executed in the kernel, not in the browser.
    c. Introduces more challenges with regard to serving our computational users who would want to programmatically run methods and view outputs.

The work described here will change those cells to run as semi-automatic code cells, following a similar pattern already performed by the GenePattern project. Any user interaction that would generate a visual cell (whether app, output, or viewer) would generate a piece of code injected into a code cell. This cell would be automatically run to produce the interactive viewer. This viewer would then have a toggle button to optionally show the code that (a) generated it and (b) is run by it, in the case of method cells.

These cell modifications will standardize around the code that gets run, and will be a first good step toward enabling a KBase API that advanced computational users could use. Additionally, this will help enable a greater breadth of UI elements. Since output visualizations would then follow the Jupyter notebook standard, this would allow for more custom code to be created in SDK modules. Finally, this will be a step on the path toward creating static HTML narratives through the Jupyter nbconvert package, although this will require modification of our JavaScript visualization widgets.

### User Stories

A developer should be able to invoke their method programmatically using a KBase API command that gets generated by method cells.

A user should be able to click a button in a method, app, or viewer to see the code that generated that cell.

A user should be able to modify the code that generated a cell, run it again, and see a new cell output.

A less-computationally-savvy user should not see a difference in their user experience once the cell updates have been made.

### Narrative Mockup

(to be completed)

### Timeline

Three sprints
  1. Goal: render visualization widgets in the Narrative via some Narrative API call.
  This is mostly already doable, but this sprint will expand on the capability in two ways.
    A. Allow for widget packages built as a kbase-ui plugin to render in the Narrative.
       * Implies a way to list available widgets, import particular widgets, ensure they're loaded, etc.
       * Will require a way to build and test locally.
    B. Start migrating existing widgets in the narrative repo into a kbase-ui plugin for loading in both the NI and landing pages.
    C. Widgets generated this way should look identical to current widgets, but should be able to toggle their Code Cell input area.

  A successful sprint here would result in a simple API (at least a prototype) that allows for running widgets that save and restore state in such a way that they're indistinguishable from other Jupyter cell commands (e.g. runs done with Plot.ly or matplotlib)

  2. Goal: prototype an API that executes jobs programmatically.
    A. Job running should behave as it does now - creates and manages a job in the Jobs Panel, also creates a Job Object that can be queried for status, logs, and result widgets.
    B. Newly clicked method cells should be invoked by similar code cells. Clicking the Run button should execute code via the API.
    C. Test the API with internal users.

  A successful sprint here would produce a prototype, possibly incomplete API that would likely consist of accessory functions for fetching KBase App information and Job management.

  3. Goal: finalize the standardization
    A. Clean up the prototype API based on testing and interaction with internal users.
    B. Finalize cell rendering functionality to be entirely based on code cells.
    C. Build a Narrative updater that will migrate existing Narratives using Markdown cells to the new format.

  A successful final sprint will have an initial release of the programmatic API, as well as using it internally for all new point-and-click based method calls.

  1. Render method / app cells as code cells. This will necessitate writing a fairly simple interface (or, at least, simpler) for executing jobs.
  2. Render data viewers and method output widgets in code cells, modify a few existing viewers to make use of the kernel for data fetching/rendering.
  3. Standardize all method, app, and viewers to behave as expected for code cells. A final stretch for this sprint would be to try to statically render all output as HTML using Jupyter's nbconvert package.

### Test Plan

Testing is critical to this project. As it is mainly a refactor project, testing should focus on automated regression tests - making sure that app cells continue to render and run in a similar way.